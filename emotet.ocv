param NA.
param NB.


(**** Gap Diffie-Hellman ****)
type G [bounded,large].  (* type of public keys *)
type G8 [bounded,large]. (* type of { X^k, X \in F_p } *)
fun G_to_bitstring(G): bitstring [data].
type Z [bounded,large,nonuniform].   (* type of exponents (must be "bounded" and
                               "large", is the set of multiples of k prime to qq' modulo kqq'.) *)
const dummy_z: Z.      (* placeholder when we do not compromise the ephemerals *)
proba P_GDH.            (* probability of breaking the GDH assumption *)
proba P_DistRerandom.
(* Page 7 in the Noise paper, rev 33:
   The public_key either encodes some value in a large prime-order group
   (which may have multiple equivalent encodings), or is an invalid
   value. *)

expand DH_X25519(
  (* types *)
  G,  (* Public keys *)
  Z,  (* Exponents *)
  (* variables *)
  g,    (* base point *)
  exp,  (* exponentiation function *)
  mult, (* multiplication function for exponents *)
  G8,
  g8,
  exp_div8,
  exp_div8', (* a symbol that replaces exp_div8 after game transformation *)
  pow8,
  G8_to_G,
  is_zero,
  is_zero8
).



const dummy: G.

type aeskey [bounded,large].
proba Phash.


expand CollisionResistant_hash(G, G, aeskey, hash, sha_oracle, Phash).

letfun sha(obj:G) = hash(dummy, obj).

type text [bounded, large].

proba Penc.
proba Pencctxt.
expand IND_CPA_INT_CTXT_sym_enc(aeskey, text, text, aes, deaes, injbot, Znull, Penc, Pencctxt).


type host [bounded].

(* The two honest peers *)
const A,B:host.

event Asent(text).
event Breceived(text).

query secret message.

query m: text;
  event(Breceived(m)) ==> event(Asent(m)).



let processA(pubS: G, pubR: G, mess: text) =
  OA1() :=
    a <-R Z;
    ga <- exp(g,a);
    return(A, B, ga);

  OA3(=B, =A, gb:G) :=
    shared <- exp(gb, a);
    aeskey <- sha(shared);



    mess <-R text;
    cipher <- aes(mess, aeskey);

    event Asent(mess);
    return(A, B, cipher).

let processB(pubS: G, pubR: G) =
  OB2(=A, =B, ga:G) :=
    b <-R Z;
    gb <- exp(g,b);
    shared <- exp(ga, b);
    aeskey <- sha(shared);

    return(B, A, gb);

  OB4(=A, =B, cipher:text) :=
    let injbot(decipher) = deaes(cipher, aeskey) in
    event Breceived(decipher);
    return().




process
	Ostart() :=
  pubS <-R G;
  pubR <-R G;
  message <-R text;
  return;
  (
   (run processA(pubS, pubR, message))
   |
   (run processB(pubS, pubR))
  )
