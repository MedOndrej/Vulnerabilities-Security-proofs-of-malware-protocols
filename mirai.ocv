param NA.
param NB.
param NAdv.

set minAutoCollElim = pest8.
proof {
   allowed_collisions pest8;
   auto
   }

type host [bounded].
type key [size8].

(* The two honest peers *)
const A,B:host.

proba Penc.
proba Pencctxt.

(* Stucrypt *)

letfun keygen() =
  k1 <-R key;
  k2 <-R key;
  k3 <-R key;
  k4 <-R key;
  (k1, k2, k3, k4).

expand MiraiAddition(key, key, key, add).

expand Xor(key, xor, zero).

(* Queries *)

event asent(key).
event breceived(key).
event AdversaryGuess(key).

(*
query m: key;
  event(breceived(m)) ==> event(asent(m)).
*)

query m: key;
  (event(asent(m)) && event(AdversaryGuess(m))) ==> false.

(*
query secret message.
*)

let processA(keyA:key, m:key) =
  OA() :=
    cipher <- xor(m, keyA);
    event asent(m);
    return(A, B, cipher).

let processB(keyB:key) =
  OB(=A, =B, cipher:key) :=
    let plain = xor(cipher, keyB) in
    event breceived(plain);
    return().

let processAdv() =
  OAdv(=A, =B, cipher:key) :=
    let (k1:key, k2:key, k3:key, k4:key) = keygen() in
    keyguess <- add(add(k1, k2), add(k3, k4));
    let messageguess = xor(cipher, keyguess) in
    event AdversaryGuess(messageguess);

    return().


process
	Ostart() :=
  let (k1:key, k2:key, k3:key, k4:key) = keygen() in
  sharedkey <- add(add(k1, k2), add(k3, k4));
  message <-R key;
	return;
  (
   (run processA(sharedkey, message))
   |
   (run processB(sharedkey))
   |
   (run processAdv())
  )
